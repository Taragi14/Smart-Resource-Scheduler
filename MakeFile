# Smart Resource Scheduler Makefile
# Supports both development and production builds

# Compiler settings
CXX = g++
CXXFLAGS = -std=c++17 -Wall -Wextra -Wpedantic -Wno-unused-parameter
INCLUDES = -Iinclude -Isrc
LIBS = -lpthread -lrt -lncurses

# Build modes
DEBUG_FLAGS = -g -DDEBUG -O0 -fsanitize=address -fsanitize=undefined
RELEASE_FLAGS = -O3 -DNDEBUG -march=native -flto
PROFILE_FLAGS = -g -O2 -pg

# Directories
SRC_DIR = src
BUILD_DIR = build
OBJ_DIR = $(BUILD_DIR)/obj
BIN_DIR = $(BUILD_DIR)/bin
TEST_DIR = tests

# Build mode (default: debug)
BUILD_MODE ?= debug

# Set flags based on build mode
ifeq ($(BUILD_MODE), release)
    CXXFLAGS += $(RELEASE_FLAGS)
    TARGET_DIR = $(BIN_DIR)/release
else ifeq ($(BUILD_MODE), profile)
    CXXFLAGS += $(PROFILE_FLAGS)
    TARGET_DIR = $(BIN_DIR)/profile
else
    CXXFLAGS += $(DEBUG_FLAGS)
    TARGET_DIR = $(BIN_DIR)/debug
endif

# Target executable
TARGET = $(TARGET_DIR)/smart_scheduler

# Source files
CORE_SOURCES = $(wildcard $(SRC_DIR)/core/*.cpp)
MODE_SOURCES = $(wildcard $(SRC_DIR)/modes/*.cpp)
SYNC_SOURCES = $(wildcard $(SRC_DIR)/synchronization/*.cpp)
LOG_SOURCES = $(wildcard $(SRC_DIR)/logging/*.cpp)
UTIL_SOURCES = $(wildcard $(SRC_DIR)/utils/*.cpp)
UI_SOURCES = $(wildcard $(SRC_DIR)/ui/*.cpp)
MAIN_SOURCE = $(SRC_DIR)/main.cpp

ALL_SOURCES = $(CORE_SOURCES) $(MODE_SOURCES) $(SYNC_SOURCES) $(LOG_SOURCES) $(UTIL_SOURCES) $(UI_SOURCES) $(MAIN_SOURCE)

# Object files
CORE_OBJECTS = $(CORE_SOURCES:$(SRC_DIR)/%.cpp=$(OBJ_DIR)/%.o)
MODE_OBJECTS = $(MODE_SOURCES:$(SRC_DIR)/%.cpp=$(OBJ_DIR)/%.o)
SYNC_OBJECTS = $(SYNC_SOURCES:$(SRC_DIR)/%.cpp=$(OBJ_DIR)/%.o)
LOG_OBJECTS = $(LOG_SOURCES:$(SRC_DIR)/%.cpp=$(OBJ_DIR)/%.o)
UTIL_OBJECTS = $(UTIL_SOURCES:$(SRC_DIR)/%.cpp=$(OBJ_DIR)/%.o)
UI_OBJECTS = $(UI_SOURCES:$(SRC_DIR)/%.cpp=$(OBJ_DIR)/%.o)
MAIN_OBJECT = $(MAIN_SOURCE:$(SRC_DIR)/%.cpp=$(OBJ_DIR)/%.o)

ALL_OBJECTS = $(CORE_OBJECTS) $(MODE_OBJECTS) $(SYNC_OBJECTS) $(LOG_OBJECTS) $(UTIL_OBJECTS) $(UI_OBJECTS) $(MAIN_OBJECT)

# Check for ncurses
HAS_NCURSES := $(shell pkg-config --exists ncurses && echo yes || echo no)

ifeq ($(HAS_NCURSES), yes)
    NCURSES_CFLAGS = $(shell pkg-config --cflags ncurses)
    NCURSES_LIBS = $(shell pkg-config --libs ncurses)
    CXXFLAGS += $(NCURSES_CFLAGS) -DHAS_NCURSES
    LIBS += $(NCURSES_LIBS)
else
    $(warning "ncurses not found - Dashboard will use simple console mode")
    CXXFLAGS += -DNO_NCURSES
endif

# Default target
.PHONY: all
all: check-deps $(TARGET)

# Check dependencies
.PHONY: check-deps
check-deps:
	@echo "Checking dependencies..."
	@which g++ > /dev/null || (echo "ERROR: g++ not found. Install with: sudo apt install build-essential" && exit 1)
	@which pkg-config > /dev/null || (echo "WARNING: pkg-config not found")
	@pkg-config --exists ncurses || echo "WARNING: ncurses not found. Install with: sudo apt install libncurses5-dev"
	@echo "Dependencies check complete"

# Main executable
$(TARGET): $(ALL_OBJECTS) | $(TARGET_DIR)
	@echo "Linking $(TARGET)..."
	$(CXX) $(CXXFLAGS) $(ALL_OBJECTS) -o $(TARGET) $(LIBS)
	@echo "Build complete: $(TARGET)"

# Object file rules
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp | $(OBJ_DIR)
	@mkdir -p $(dir $@)
	@echo "Compiling $<..."
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@
    GTK_CFLAGS = $(shell pkg-config --cflags gtk+-3.0)
    GTK_LIBS = $(shell pkg-config --libs gtk+-3.0)
    CXXFLAGS += $(GTK_CFLAGS) -DUSE_GTK
    LIBS += $(GTK_LIBS)
endif

# Default target
.PHONY: all
all: $(TARGET)

# Main executable
$(TARGET): $(ALL_OBJECTS) | $(TARGET_DIR)
	@echo "Linking $(TARGET)..."
	$(CXX) $(CXXFLAGS) $(ALL_OBJECTS) -o $(TARGET) $(LIBS)
	@echo "Build complete: $(TARGET)"

# Object file rules
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp | $(OBJ_DIR)
	@mkdir -p $(dir $@)
	@echo "Compiling $<..."
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@

# Test object files
$(OBJ_DIR)/tests/%.o: $(TEST_DIR)/%.cpp | $(OBJ_DIR)/tests
	@echo "Compiling test $<..."
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@

# Test executable (excluding main.o)
$(TEST_TARGET): $(filter-out $(MAIN_OBJECT), $(ALL_OBJECTS)) $(TEST_OBJECTS) | $(TARGET_DIR)
	@echo "Linking tests..."
	$(CXX) $(CXXFLAGS) $(filter-out $(MAIN_OBJECT), $(ALL_OBJECTS)) $(TEST_OBJECTS) -o $(TEST_TARGET) $(LIBS) -lgtest -lgtest_main
	@echo "Test build complete: $(TEST_TARGET)"

# Directory creation
$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)

$(OBJ_DIR): | $(BUILD_DIR)
	mkdir -p $(OBJ_DIR)
	mkdir -p $(OBJ_DIR)/core
	mkdir -p $(OBJ_DIR)/modes
	mkdir -p $(OBJ_DIR)/synchronization
	mkdir -p $(OBJ_DIR)/logging
	mkdir -p $(OBJ_DIR)/utils
	mkdir -p $(OBJ_DIR)/ui

$(TARGET_DIR): | $(BUILD_DIR)
	mkdir -p $(TARGET_DIR)

$(OBJ_DIR)/tests: | $(OBJ_DIR)
	mkdir -p $(OBJ_DIR)/tests

# Build modes
.PHONY: debug release profile
debug:
	$(MAKE) BUILD_MODE=debug

release:
	$(MAKE) BUILD_MODE=release

profile:
	$(MAKE) BUILD_MODE=profile

# Testing
.PHONY: test test-build run-tests
test-build: $(TEST_TARGET)

test: test-build
	@echo "Running tests..."
	$(TEST_TARGET)

run-tests: test

# Installation
.PHONY: install uninstall
INSTALL_PREFIX ?= /usr/local
INSTALL_BIN_DIR = $(INSTALL_PREFIX)/bin
INSTALL_CONFIG_DIR = /etc/smart_scheduler
INSTALL_SERVICE_DIR = /etc/systemd/system

install: release
	@echo "Installing Smart Resource Scheduler..."
	sudo mkdir -p $(INSTALL_BIN_DIR)
	sudo mkdir -p $(INSTALL_CONFIG_DIR)
	sudo cp $(BIN_DIR)/release/smart_scheduler $(INSTALL_BIN_DIR)/
	sudo chmod +x $(INSTALL_BIN_DIR)/smart_scheduler
	sudo cp -r config/* $(INSTALL_CONFIG_DIR)/
	@if [ -f scripts/smart_scheduler.service ]; then \
		sudo cp scripts/smart_scheduler.service $(INSTALL_SERVICE_DIR)/; \
		sudo systemctl daemon-reload; \
		echo "Systemd service installed. Enable with: sudo systemctl enable smart_scheduler"; \
	fi
	@echo "Installation complete!"
	@echo "Run with: smart_scheduler"
	@echo "Or as daemon: sudo systemctl start smart_scheduler"

uninstall:
	@echo "Uninstalling Smart Resource Scheduler..."
	sudo systemctl stop smart_scheduler 2>/dev/null || true
	sudo systemctl disable smart_scheduler 2>/dev/null || true
	sudo rm -f $(INSTALL_BIN_DIR)/smart_scheduler
	sudo rm -rf $(INSTALL_CONFIG_DIR)
	sudo rm -f $(INSTALL_SERVICE_DIR)/smart_scheduler.service
	sudo systemctl daemon-reload
	@echo "Uninstallation complete!"

# Package creation
.PHONY: package deb rpm
PACKAGE_NAME = smart-resource-scheduler
VERSION = 1.0.0

package: release
	@echo "Creating package..."
	mkdir -p package/$(PACKAGE_NAME)-$(VERSION)
	cp -r $(BIN_DIR)/release/* package/$(PACKAGE_NAME)-$(VERSION)/
	cp -r config package/$(PACKAGE_NAME)-$(VERSION)/
	cp -r docs package/$(PACKAGE_NAME)-$(VERSION)/
	cp README.md LICENSE package/$(PACKAGE_NAME)-$(VERSION)/
	cd package && tar -czf $(PACKAGE_NAME)-$(VERSION).tar.gz $(PACKAGE_NAME)-$(VERSION)
	@echo "Package created: package/$(PACKAGE_NAME)-$(VERSION).tar.gz"

# Debian package
deb: release
	@echo "Creating Debian package..."
	mkdir -p package/deb/$(PACKAGE_NAME)_$(VERSION)/DEBIAN
	mkdir -p package/deb/$(PACKAGE_NAME)_$(VERSION)/usr/bin
	mkdir -p package/deb/$(PACKAGE_NAME)_$(VERSION)/etc/smart_scheduler
	mkdir -p package/deb/$(PACKAGE_NAME)_$(VERSION)/etc/systemd/system
	
	# Copy files
	cp $(BIN_DIR)/release/smart_scheduler package/deb/$(PACKAGE_NAME)_$(VERSION)/usr/bin/
	cp -r config/* package/deb/$(PACKAGE_NAME)_$(VERSION)/etc/smart_scheduler/
	cp scripts/smart_scheduler.service package/deb/$(PACKAGE_NAME)_$(VERSION)/etc/systemd/system/
	
	# Create control file
	@echo "Package: $(PACKAGE_NAME)" > package/deb/$(PACKAGE_NAME)_$(VERSION)/DEBIAN/control
	@echo "Version: $(VERSION)" >> package/deb/$(PACKAGE_NAME)_$(VERSION)/DEBIAN/control
	@echo "Architecture: amd64" >> package/deb/$(PACKAGE_NAME)_$(VERSION)/DEBIAN/control
	@echo "Maintainer: Smart Scheduler Team <team@smartscheduler.com>" >> package/deb/$(PACKAGE_NAME)_$(VERSION)/DEBIAN/control
	@echo "Description: Smart Resource Scheduler for Personal PCs" >> package/deb/$(PACKAGE_NAME)_$(VERSION)/DEBIAN/control
	@echo "Depends: libc6, libstdc++6, libjsoncpp1" >> package/deb/$(PACKAGE_NAME)_$(VERSION)/DEBIAN/control
	
	cd package/deb && dpkg-deb --build $(PACKAGE_NAME)_$(VERSION)
	@echo "Debian package created: package/deb/$(PACKAGE_NAME)_$(VERSION).deb"

# Development helpers
.PHONY: clean clean-all format lint check-deps run run-daemon run-console
clean:
	@echo "Cleaning build files..."
	rm -rf $(BUILD_DIR)

clean-all: clean
	@echo "Cleaning all generated files..."
	rm -rf package/
	rm -f *.log

format:
	@echo "Formatting code..."
	find src include -name "*.cpp" -o -name "*.h" | xargs clang-format -i

lint:
	@echo "Running static analysis..."
	cppcheck --enable=all --std=c++17 src/ include/

check-deps:
	@echo "Checking dependencies..."
	@which g++ > /dev/null || (echo "g++ not found" && exit 1)
	@pkg-config --exists jsoncpp || (echo "jsoncpp not found" && exit 1)
	@echo "All dependencies satisfied"

# Run targets
run: debug
	sudo $(TARGET)

run-daemon: debug
	sudo $(TARGET) --daemon

run-console: debug
	sudo $(TARGET) --no-gui

# Development with different UI libraries
.PHONY: qt gtk
qt:
	$(MAKE) USE_QT=yes

gtk:
	$(MAKE) USE_GTK=yes

# Documentation generation
.PHONY: docs
docs:
	@echo "Generating documentation..."
	doxygen docs/Doxyfile
	@echo "Documentation generated in docs/html/"

# Performance profiling
.PHONY: profile-run profile-report
profile-run: profile
	sudo $(BIN_DIR)/profile/smart_scheduler --daemon &
	sleep 60
	sudo pkill smart_scheduler

profile-report: profile-run
	gprof $(BIN_DIR)/profile/smart_scheduler gmon.out > profile_report.txt
	@echo "Profile report generated: profile_report.txt"

# Memory leak checking
.PHONY: valgrind
valgrind: debug
	sudo valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes $(TARGET) --no-gui

# Code coverage
.PHONY: coverage
COVERAGE_FLAGS = -fprofile-arcs -ftest-coverage
coverage:
	$(MAKE) BUILD_MODE=debug CXXFLAGS="$(DEBUG_FLAGS) $(COVERAGE_FLAGS)" LIBS="$(LIBS) -lgcov"
	$(MAKE) test
	gcov $(ALL_SOURCES)
	lcov --capture --directory . --output-file coverage.info
	genhtml coverage.info --output-directory coverage_report
	@echo "Coverage report generated in coverage_report/"

# Benchmark
.PHONY: benchmark benchmark-build
BENCHMARK_SOURCES = $(wildcard tests/benchmark/*.cpp)
BENCHMARK_OBJECTS = $(BENCHMARK_SOURCES:tests/benchmark/%.cpp=$(OBJ_DIR)/benchmark/%.o)
BENCHMARK_TARGET = $(TARGET_DIR)/benchmark

$(OBJ_DIR)/benchmark/%.o: tests/benchmark/%.cpp | $(OBJ_DIR)/benchmark
	@echo "Compiling benchmark $<..."
	$(CXX) $(CXXFLAGS) $(INCLUDES) -c $< -o $@

$(OBJ_DIR)/benchmark: | $(OBJ_DIR)
	mkdir -p $(OBJ_DIR)/benchmark

benchmark-build: $(BENCHMARK_TARGET)

$(BENCHMARK_TARGET): $(filter-out $(MAIN_OBJECT), $(ALL_OBJECTS)) $(BENCHMARK_OBJECTS) | $(TARGET_DIR)
	@echo "Linking benchmarks..."
	$(CXX) $(CXXFLAGS) $(filter-out $(MAIN_OBJECT), $(ALL_OBJECTS)) $(BENCHMARK_OBJECTS) -o $(BENCHMARK_TARGET) $(LIBS) -lbenchmark -lbenchmark_main
	@echo "Benchmark build complete: $(BENCHMARK_TARGET)"

benchmark: benchmark-build
	@echo "Running benchmarks..."
	$(BENCHMARK_TARGET)

# Help
.PHONY: help
help:
	@echo "Smart Resource Scheduler Build System"
	@echo ""
	@echo "Targets:"
	@echo "  all          - Build the main executable (default: debug mode)"
	@echo "  debug        - Build in debug mode with sanitizers"
	@echo "  release      - Build optimized release version"
	@echo "  profile      - Build with profiling enabled"
	@echo ""
	@echo "Testing:"
	@echo "  test         - Build and run unit tests"
	@echo "  test-build   - Build tests only"
	@echo "  benchmark    - Build and run benchmarks"
	@echo "  valgrind     - Run with memory leak detection"
	@echo "  coverage     - Generate code coverage report"
	@echo ""
	@echo "Installation:"
	@echo "  install      - Install system-wide (requires sudo)"
	@echo "  uninstall    - Remove system installation"
	@echo "  package      - Create tarball package"
	@echo "  deb          - Create Debian package"
	@echo ""
	@echo "Development:"
	@echo "  clean        - Clean build files"
	@echo "  clean-all    - Clean all generated files"
	@echo "  format       - Format code with clang-format"
	@echo "  lint         - Run static analysis"
	@echo "  docs         - Generate documentation"
	@echo ""
	@echo "Running:"
	@echo "  run          - Run in GUI mode (debug build)"
	@echo "  run-daemon   - Run as daemon (debug build)"
	@echo "  run-console  - Run in console mode (debug build)"
	@echo ""
	@echo "UI Options:"
	@echo "  qt           - Build with Qt UI support"
	@echo "  gtk          - Build with GTK UI support"
	@echo ""
	@echo "Variables:"
	@echo "  BUILD_MODE   - debug|release|profile (default: debug)"
	@echo "  USE_QT       - yes|no (default: no)"
	@echo "  USE_GTK      - yes|no (default: no)"